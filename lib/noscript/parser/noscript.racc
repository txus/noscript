#
# Noscript grammar.
#

class Noscript::Parser

prechigh
    nonassoc UMINUS
    left '*' '/'
    left '+' '-'
preclow

rule
  target : statements
         | /* none */ { 0 }

  assignment : identifier '.' identifier ASSIGN statement { result = AST::AssignNode.new(val[0], val[2], val[4]) }
             | identifier ASSIGN statement { result = AST::AssignNode.new(nil, val[0], val[2]) }

  fun_definition : FUN parameter_list end_of_statement statements END { result = AST::FunNode.new(val[1], val[3]) }

  message : identifier '.' identifier { result = AST::Message.new(val[0], val[2]) }
          | identifier '.' fun_call { result = AST::Message.new(val[0], val[2]) }
          | fun_call { result = AST::Message.new(nil, val[0]) }

  if_else : IF expression end_of_statement statements ELSE end_of_statement statements END { result = AST::IfNode.new(val[1], val[3], val[6]) }
          | IF expression end_of_statement statements END { result = AST::IfNode.new(val[1], val[3]) }

  while   : WHILE expression end_of_statement statements END { result = AST::WhileNode.new(val[1], val[3]) }

  identifier : IDENTIFIER { result = AST::Identifier.new(val[0]) }
             | DEREF { result = AST::Identifier.new(val[0], true)}

  digit : DIGIT { result = AST::Digit.new(val[0]) }
  string : STRING { result = AST::String.new(val[0]) }
  tuple : '{' tuple_elements '}' { result = AST::Tuple.new(val[1]) }

  tuple_element : IDENTIFIER ':' argument { result = {val[0] => val[2]} }
                | end_of_statement tuple_element { result = val[1] }
                | tuple_element end_of_statement { result = val[0]}

  tuple_elements : { result = {} }
                 | tuple_element { result.merge!(val[0]) }
                 | tuple_elements COMMA tuple_element { result.merge!(val[2]) }

  literal : digit
          | string
          | tuple
          | fun_definition
          | boolean_literal
          | operation

  argument : identifier
           | literal
           | message

  argument_list : { result = [] }
                | argument  { result = [val[0]] }
                | argument_list COMMA argument { result.push(val[2]) }

  parameter : identifier ASSIGN argument { result = AST::DefaultParameter.new(val[0], val[2])}
            | identifier

  parameter_list : { result = [] }
                 | parameter { result = [val[0]] }
                 | parameter_list COMMA parameter { result.push(val[2]) }

  boolean_exp : op_member EQUALS op_member { result = AST::EqualityExpression.new(val[0], val[2]) }
              | op_member NEQUALS op_member { result = AST::InequalityExpression.new(val[0], val[2]) }
              | op_member GT_OP op_member { result = AST::GtExpression.new(val[0], val[2]) }
              | op_member GTE_OP op_member { result = AST::GteExpression.new(val[0], val[2]) }
              | op_member LT_OP op_member { result = AST::LtExpression.new(val[0], val[2]) }
              | op_member LTE_OP op_member { result = AST::LteExpression.new(val[0], val[2]) }
              | boolean_literal

  boolean_literal : TRUE { result = AST::True.new }
                  | FALSE { result = AST::False.new }
                  | NIL { result = AST::Nil.new }

  expression : boolean_exp
             | LPAREN expression RPAREN

  statement : assignment
            | expression
            | message
            | literal
            | if_else
            | while
            | op_member
            | statement end_of_statement

  op_member : digit
            | identifier
            | boolean_literal
            | message
            | operation

  operation : op_member '+' op_member { result = AST::AddNode.new(val[0], val[2]) }
            | op_member '-' op_member { result = AST::SubtractNode.new(val[0], val[2]) }
            | op_member '*' op_member { result = AST::MultiplicationNode.new(val[0], val[2]) }
            | op_member '/' op_member { result = AST::DivisionNode.new(val[0], val[2]) }
            | LPAREN op_member RPAREN { result = val[1] }
            | '-' op_member  =UMINUS { result = AST::UnaryMinus.new(val[1]) }

  statements : { result = AST::Nodes.new([]) }
             | statement { result = AST::Nodes.new([val[0]]) }
             | statements statement { result.push(val[1]) }

  end_of_statement : SEMICOLON | NEWLINE

  fun_call : identifier LPAREN argument_list RPAREN
             {
               result = AST::FunCall.new(val[0], val[2])
             }


---- header ----
#
# generated by racc
#
require_relative 'noscript.rex'

---- inner ----

---- footer ----
