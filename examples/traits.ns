# = Noscript Traits
#
# Traits are similar to Ruby Modules (in the sense of mixins), but they differ
# regarding conflict resolution.
#
# == The problem with Ruby modules
#
# In Ruby, when a Module is included in a Class, it defines a series of methods
# that can be used by instances of that class. However, the class is free to
# override whatever methods it wants, to adapt the behavior of the module at
# will.
#
# Because of how the Ruby inheritance chain works, modules are included
# hierarchically, so the last module included (or the last method defined)
# wins, so to speak. As an example, imagine two Ruby modules, +Sports+ and
# +Businessman+, that are to be included in a Person class. Both of them
# implement the #run method.
#
#   class Person
#     include Sports
#     include Businessman
#   end
#
# We know that Person#run will call the #run defined in Businessman, because
# it is the last module included and has overriden the previously defined
# Sports#run.
#
# However, that is clearly a conflict. The user does not know explicitly that
# the conflict has taken place, and it may even not know that Businessman is
# implementing a method with the same name as Sports.
#
# == Traits: explicit conflict resolution, no hierarchy, truly composable
#
# Traits are like Ruby modules in the sense that they can be used to define
# composable units of behavior, but they are not included hierarchically. They
# are truly composable, meaning that are pieces that *must* either fit
# perfectly or the host object must provide a way for them to do it, normally
# resolving conflicts by explicitly redefining the conflicting methods.
#
# You can read more about traits in the following paper by Nathanael SchÃ¤rli:
#
#   http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf
#
# == Traits in Noscript
#
# We are going to solve the Sports / Businessman problem using Noscript traits:

# Create a Sportsman trait that implements #run at a given speed.
Sports = trait({
  run: -> speed
    puts('#{@name} is running')
  end
})

# Create a Businessman trait that also implements #run, but in the sense of
# running a particular business.
Businessman = trait({
  run: -> business
    puts('#{@name} is running a profitable business!')
  end
})

person = Object.clone({
  name: 'John',
  business: Object.clone({name: 'Johnny Cash Inc.'})
})

# By making +person+ use Sports, now person implements Sports#run.
person.uses(Sports)

# Since we want +person+ to implement Businessman#run as well, and simply using
# the Businessman trait would create a conflict (since both Sports and
# Businessman implement the same message), we need to *explicitly* resolve that
# conflict by letting +person+ decide what #run means.
#
# In our case, +person+ decides that Sports#run should be ran if a speed is
# given - otherwise, Businessman#run should be called
#
# Note that, in order to disambiguate, we must call each message prepended by
# the trait name.
person.run = -> speed=nil
  if speed == nil # If no arguments were given, run a business
    @Businessman run(@business)
  else # Otherwise run at the given speed!
    @Sports run(speed)
  end
end

# Now +person+ can safely use the Businessman trait with no conflicts.
person.uses(Businessman)

# Will run as a sportsman:
person.run(10)

# Will run as a businessman:
person.run()
